import{_ as s,o as n,c as a,a as p}from"./app-fe457d72.js";const e="/assets/20231221105433-d816aea2.png",t="/assets/20231221105534-ad0c5abf.png",o="/assets/20231221105629-e20f11ef.png",l="/assets/20231221110209-b87fb9e6.png",i="/assets/20231221110312-6c0190d8.png",r="/assets/20231221110424-33e90443.png",c="/assets/20231221111322-0286253d.png",d="/assets/20231221111421-865d5dbf.png",u="/assets/20231221111516-067dc196.png",k="/assets/20231221111641-7639ab6c.png",g="/assets/20231221160209-417fd9fb.png",m="/assets/20231221160720-8d756624.png",v="/assets/20231221160909-3492fa8b.png",b="/assets/20231221161051-f0017fc4.png",y="/assets/20231221161209-e4a36728.png",h="/assets/20231221161344-c8ee1e2b.png",f="/assets/20231221161437-bc066f5b.png",_="/assets/20231221163401-14730cac.png",T="/assets/20231221163612-996820b5.png",P="/assets/20231221165012-f3c7bf5f.png",x="/assets/20231221165141-60afbb68.png",w="/assets/20231221165644-4184864d.png",S="/assets/20231221170131-ac4aae55.png",K="/assets/20231221171229-6ad98a8a.png",R="/assets/20231221172346-9c139eb3.png",N="/assets/20231221173713-e9151aab.png",D="/assets/20231221173748-3d45900e.png",F="/assets/20231221174622-1bac883f.png",j="/assets/20231221174703-26f058dd.png",A="/assets/20231221174749-319f62a7.png",J="/assets/20231221175003-ddc39aa1.png",C={},I=p('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>TS 中的高级类型有很多，重点学习以下高级类型：</p><ol><li><p>class 类</p></li><li><p>类型兼容性</p></li><li><p>交叉类型</p></li><li><p>泛型 和 keyof</p></li><li><p>索引签名类型 和 索引查询类型</p></li><li><p>映射类型</p></li></ol><h2 id="_4-1-class-类" tabindex="-1"><a class="header-anchor" href="#_4-1-class-类" aria-hidden="true">#</a> 4.1 class 类</h2><p>TypeScript 全面支持 ES2015 中引入的 <strong>class</strong> 关键字，并为其添加了类型注解和其他语法（比如，可见性修饰符等）</p><p><img src="'+e+'" alt=""></p><p>解释：</p><ol><li>根据 TS 中的类型推论，可以知道 Person 类的实例对象 p 的类型是 Person。</li><li>TS 中的 class，不仅提供了 <strong>class 的语法功能，也作为一种类型存在</strong>。</li></ol><hr><p>实例属性初始化：</p><p><img src="'+t+'" alt=""></p><p>解释：</p><ol><li>声明成员 age，类型为 number（没有初始值）。</li><li>声明成员 gender，并设置初始值，此时，可省略类型注解（TS <strong>类型推论</strong> 为 string 类型）。</li></ol><hr><p>构造函数：</p><p><img src="'+o+'" alt=""></p><p>解释：</p><ol><li>成员初始化（比如，age: number）后，才可以通过 this.age 来访问实例成员。</li><li>需要为构造函数指定类型注解，否则会被隐式推断为 any；构造函数不需要返回值类型。</li></ol><hr><p>实例方法：</p><p><img src="'+l+'" alt=""></p><p>解释：方法的类型注解（参数和返回值）与函数用法相同。</p><hr><p>类继承的两种方式：1 <strong>extends</strong>（继承父类） 2 implements（实现接口）。</p><p>说明：JS 中只有 extends，而 implements 是 TS 提供的。</p><p><img src="'+i+'" alt=""></p><p>解释：</p><ol><li>通过 <strong>extends</strong> 关键字实现<strong>继承</strong>。</li><li>子类 Dog 继承父类 Animal，则 Dog 的实例对象 dog 就同时具有了父类 Animal 和 子类 Dog 的所有属性和方法。</li></ol><hr><p>类继承的两种方式：1 extends（继承父类） 2 <strong>implements</strong>（实现接口）。</p><p><img src="'+r+'" alt=""></p><p>解释：</p><ol><li>通过 <strong>implements</strong> 关键字让 class 实现接口。</li><li>Person 类实现接口 Singable 意味着，Person 类中必须提供 Singable 接口中指定的所有方法和属性。</li></ol><hr><p>类成员可见性：可以使用 TS 来<strong>控制 class 的方法或属性对于 class 外的代码是否可见</strong>。 可见性修饰符包括：1 <strong>public（公有的）</strong> 2 protected（受保护的） 3 private（私有的）。</p><ol><li>public：表示公有的、公开的，<strong>公有成员可以被任何地方访问</strong>，默认可见性。</li></ol><p><img src="'+c+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>public</strong> 关键字，来修饰该属性或方法是共有的。</li><li>因为 public 是默认可见性，所以，可以<strong>直接省略</strong>。</li></ol><hr><ol start="2"><li><strong>protected</strong>：表示<strong>受保护的</strong>，仅对其声明所在类和子类中（非实例对象）可见。</li></ol><p><img src="'+d+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>protected</strong> 关键字，来修饰该属性或方法是受保护的。</li><li>在子类的方法内部可以通过 this 来访问父类中受保护的成员，但是，<strong>对实例不可见</strong>！</li></ol><hr><ol start="3"><li><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的。</li></ol><p><img src="'+u+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>private</strong> 关键字，来修饰该属性或方法是私有的。</li><li>私有的属性或方法只在当前类中可见，对子类和实例对象也都是不可见的！</li></ol><hr><p>除了可见性修饰符之外，还有一个常见修饰符就是：<strong>readonly（只读修饰符）</strong>。</p><p><strong>readonly</strong>：表示<strong>只读，用来防止在构造函数之外对属性进行赋值</strong>。</p><p><img src="'+k+'" alt=""></p><p>解释：</p><ol><li>使用 <strong>readonly</strong> 关键字修饰该属性是只读的，注意<strong>只能修饰属性不能修饰方法</strong>。</li><li>注意：属性 age 后面的类型注解（比如，此处的 number）如果不加，则 age 的类型为 18 （<strong>字面量类型</strong>）。</li><li><strong>接口或者 {} 表示的对象类型，也可以使用 readonly</strong>。</li></ol><h2 id="_4-2-类型兼容性" tabindex="-1"><a class="header-anchor" href="#_4-2-类型兼容性" aria-hidden="true">#</a> 4.2 类型兼容性</h2><p>两种类型系统：1 Structural Type System（结构化类型系统） 2 Nominal Type System（标明类型系统）。</p><p><strong>TS 采用的是结构化类型系统</strong>，也叫做 duck typing（鸭子类型），<strong>类型检查关注的是值所具有的形状</strong>。</p><p>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。</p><p><img src="'+g+'" alt=""></p><p>解释：</p><ol><li><p>Point 和 Point2D 是两个名称不同的类。</p></li><li><p>变量 p 的类型被显示标注为 Point 类型，但是，它的值却是 Point2D 的实例，并且没有类型错误。</p></li><li><p>因为 TS 是结构化类型系统，只检查 Point 和 Point2D 的结构是否相同（相同，都具有 x 和 y 两个属性，属性类型也相同）。</p></li><li><p>但是，如果在 Nominal Type System 中（比如，C#、Java 等），它们是不同的类，类型无法兼容。</p></li></ol><hr><p>注意：在结构化类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型，这种说法并不准确。</p><p><strong>更准确的说法：对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（成员多的可以赋值给少的）</strong>。</p><p><img src="'+m+'" alt=""></p><p>解释：</p><ol><li>Point3D 的成员<strong>至少</strong>与 Point 相同，则 Point 兼容 Point3D。</li><li>所以，成员多的 Point3D 可以赋值给成员少的 Point。</li></ol><hr><p>除了 class 之外，TS 中的其他类型也存在相互兼容的情况，包括：1 <strong>接口兼容性</strong> 2 函数兼容性 等。</p><ul><li><strong>接口之间的兼容性，类似于 class</strong>。并且，class 和 interface 之间也可以兼容。</li></ul><p><img src="'+v+'" alt=""></p><ul><li><strong>函数之间兼容性比较复杂</strong>，需要考虑：1 参数个数 2 参数类型 3 返回值类型。</li></ul><p><strong>参数个数</strong>，参数多的兼容参数少的（或者说，<strong>参数少的可以赋值给多的</strong>）。</p><p><img src="'+b+'" alt=""></p><p>解释：</p><ol><li><p>参数少的可以赋值给参数多的，所以，f1 可以赋值给 f2。</p></li><li><p>数组 forEach 方法的第一个参数是回调函数，该示例中类型为：(value: string, index: number, array: string[]) =&gt; void。</p></li><li><p>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性。</p></li><li><p>并且因为回调函数是有类型的，所以，TS 会自动推导出参数 item、index、array 的类型。</p></li></ol><p><strong>参数类型</strong>，相同位置的参数类型要相同（原始类型）或兼容（对象类型）。</p><p><img src="'+y+'" alt=""></p><p>解释：函数类型 F2 兼容函数类型 F1，因为 F1 和 F2 的第一个参数类型相同。</p><p><strong>参数类型</strong>，相同位置的参数类型要相同或兼容。</p><p><img src="'+h+'" alt=""></p><p>解释：</p><ol><li><p>注意，此处与前面讲到的接口兼容性冲突。</p></li><li><p>技巧：将对象拆开，把每个属性看做一个个参数，则，参数少的（f2）可以赋值给参数多的（f3）。</p></li></ol><p><strong>返回值类型</strong>，只关注返回值类型本身即可：</p><p><img src="'+f+'" alt=""></p><p>解释：</p><ol><li><p>如果返回值类型是原始类型，此时两个类型要相同，比如，左侧类型 F5 和 F6。</p></li><li><p>如果返回值类型是对象类型，此时成员多的可以赋值给成员少的，比如，右侧类型 F7 和 F8。</p></li></ol><h2 id="_4-3-交叉类型" tabindex="-1"><a class="header-anchor" href="#_4-3-交叉类型" aria-hidden="true">#</a> 4.3 交叉类型</h2><p><strong>交叉类型（&amp;）</strong>：功能类似于接口继承（extends），用于组合多个类型为一个类型（常用于对象类型）。</p><p>比如，</p><p><img src="'+_+`" alt=""></p><p>解释：使用交叉类型后，新的类型 PersonDetail 就同时具备了 Person 和 Contact 的所有属性类型。</p><p>相当于，</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PersonDetail</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
    phone<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>交叉类型（&amp;）和接口继承（extends）的对比：</p><ul><li><p>相同点：都可以实现对象类型的组合。</p></li><li><p>不同点：两种方式实现类型组合时，对于同名属性之间，<strong>处理类型冲突的方式不同</strong>。</p></li></ul><p><img src="`+T+`" alt=""></p><p>说明：以上代码，接口继承会报错（类型不兼容）；交叉类型没有错误，可以简单的理解为：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-4-泛型" tabindex="-1"><a class="header-anchor" href="#_4-4-泛型" aria-hidden="true">#</a> 4.4 泛型</h2><p><strong>泛型</strong>是可以在<strong>保证类型安全</strong>前提下，让函数等<strong>与多种类型一起工作</strong>，从而<strong>实现复用</strong>，常用于：函数、接口、class 中。</p><p>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">id</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型。</p><p>为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">id</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>泛型</strong>在<strong>保证类型安全</strong>（不丢失类型信息）的同时，可以让函数等与多种不同的类型一起工作，灵活可复用。</p><p>实际上，在 C＃和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一。</p><hr><p>创建泛型函数：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span><span class="token operator">:</span> Type <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>语法：在函数名称的后面添加 &lt;&gt;（尖括号），<strong>尖括号中添加类型变量</strong>，比如此处的 Type。</p></li><li><p><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong>。</p></li><li><p>该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）。</p></li><li><p>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型。</p></li><li><p>类型变量 Type，可以是任意合法的变量名称。</p></li></ol><hr><p>调用泛型函数：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li>语法：在函数名称的后面添加 &lt;&gt;（尖括号），<strong>尖括号中指定具体的类型</strong>，比如，此处的 number。</li><li>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到。</li><li>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number。</li></ol><p>同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string。</p><p>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong>。</p><hr><p>简化调用泛型函数：</p><p><img src="`+P+'" alt=""></p><p>解释：</p><ol><li><p>在调用泛型函数时，<strong>可以省略 &lt;类型&gt; 来简化泛型函数的调用</strong>。</p></li><li><p>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型。</p></li><li><p>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型。</p></li></ol><p>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读。</p><p>说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数。</p><hr><p>泛型约束：默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性。</p><p>比如，id(&#39;a&#39;) 调用函数时获取参数的长度：</p><p><img src="'+x+`" alt=""></p><p>解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。</p><p>此时，就需要为泛型<strong>添加约束来收缩类型</strong>（缩窄类型取值范围）。</p><hr><p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束。</p><ol><li>指定更加具体的类型</li></ol><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如，将类型修改为 Type[]（Type 类型的数组），因为只要是数组就一定存在 length 属性，因此就可以访问了。</p><ol start="2"><li>添加约束</li></ol><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">ILength</span> <span class="token punctuation">{</span>
    length<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">id</span><span class="token generic class-name"><span class="token operator">&lt;</span>Type <span class="token keyword">extends</span> Ilength<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span><span class="token operator">:</span> Type <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>创建描述约束的接口 ILength，该接口要求提供 length 属性。</p></li><li><p>通过 <strong>extends</strong> 关键字使用该接口，为泛型（类型变量）添加约束。</p></li><li><p>该约束表示：<strong>传入的类型必须具有 length 属性</strong>。</p></li></ol><p>注意：传入的实参（比如，数组）只要有 length 属性即可，这也符合前面讲到的接口的类型兼容性。</p><hr><p>泛型的类型变量可以有多个，并且<strong>类型变量之间还可以约束</strong>（比如，第二个类型变量受第一个类型变量约束）。</p><p>比如，创建一个函数来获取对象中属性的值：</p><p><img src="`+w+`" alt=""></p><p>解释：</p><ol><li><p>添加了第二个类型变量 Key，两个类型变量之间使用（,）<strong>逗号</strong>分隔。</p></li><li><p><strong>keyof</strong> 关键字<strong>接收一个对象类型，生成其键名称（可能是字符串或数字）的联合类型</strong>。</p></li><li><p>本示例中 <strong>keyof Type</strong> 实际上获取的是 person 对象<strong>所有键的联合类型</strong>，也就是：&#39;name&#39; | &#39;age&#39;。</p></li><li><p>类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性。</p></li></ol><hr><p><strong>泛型接口</strong>：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">IdFunc<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token function-variable function">id</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Type
    <span class="token function-variable function">ids</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> IdFunc<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">id</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">ids</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>在接口名称的后面添加 <strong>&lt;类型变量&gt;</strong>，那么，这个接口就变成了泛型接口。</p></li><li><p>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong>。</p></li><li><p>使用泛型接口时，<strong>需要显式指定具体的类型</strong>（比如，此处的 <code>IdFunc&lt;nunber&gt;</code>）。</p></li><li><p>此时，id 方法的参数和返回值类型都是 number；ids 方法的返回值类型是 <code>number[]</code>。</p></li></ol><hr><p>实际上，JS 中的数组在 TS 中就是一个<strong>泛型接口</strong>。</p><p><img src="`+S+'" alt=""></p><p>解释：当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型。</p><p>技巧：可以通过 Ctrl + 鼠标左键（Mac：option + 鼠标左键）来查看具体的类型信息。</p><hr><p><strong>泛型类</strong>：class 也可以配合泛型来使用。</p><p>比如，React 的 class 组件的基类 Component 就是泛型类，不同的组件有不同的 props 和 state。</p><p><img src="'+K+`" alt=""></p><p>解释：React.Component 泛型类两个类型变量，分别指定 props 和 state 类型。</p><hr><p>创建泛型类：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>clsss GenericNumber<span class="token operator">&lt;</span>NumType<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    defaultValue<span class="token operator">:</span> NumType
    <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> NumType<span class="token punctuation">,</span> y<span class="token operator">:</span> NumType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> NumType
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>类似于泛型接口，在 class 名称后面添加 <strong>&lt;类型变量&gt;</strong>，这个类就变成了泛型类。</p></li><li><p>此处的 add 方法，采用的是箭头函数形式的类型书写方式。</p></li></ol><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> myNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
myNum<span class="token punctuation">.</span>defaultValue <span class="token operator">=</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>类似于泛型接口，在创建 class 实例时，在类名后面通过 &lt;类型&gt; 来指定明确的类型。</p><h3 id="泛型工具类" tabindex="-1"><a class="header-anchor" href="#泛型工具类" aria-hidden="true">#</a> 泛型工具类</h3><p>泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作。</p><p>说明：它们都是基于泛型实现的（泛型适用于多种类型，更加通用），并且是内置的，可以直接在代码中使用。</p><p>这些工具类型有很多，主要学习以下几个：</p><ol><li><p><code>Partial&lt;Type&gt; </code></p></li><li><p><code>Readonly&lt;Type&gt; </code></p></li><li><p><code>Pick&lt;Type, Keys&gt; </code></p></li><li><p><code>Record&lt;Keys, Type&gt;</code></p></li></ol><h4 id="partial-type" tabindex="-1"><a class="header-anchor" href="#partial-type" aria-hidden="true">#</a> <code>Partial&lt;Type&gt;</code></h4><p>泛型工具类型 - <code>Partial&lt;Type&gt;</code> 用来构造（创建）一个类型，将 Type 的所有属性设置为可选。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token builtin">string</span>
    children<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">PartialProps</span> <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。</p><h4 id="readonly-type" tabindex="-1"><a class="header-anchor" href="#readonly-type" aria-hidden="true">#</a> <code>Readonly&lt;Type&gt;</code></h4><p>泛型工具类型 - <code>Readonly&lt;Type&gt;</code> 用来构造一个类型，将 Type 的所有属性都设置为 readonly</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token builtin">string</span>
    children<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">ReadonlyProps</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。</p><p><img src="`+R+`" alt=""></p><p>当我们想重新给 id 属性赋值时，就会报错：无法分配到 &quot;id&quot; ，因为它是只读属性。</p><h4 id="pick-type-keys" tabindex="-1"><a class="header-anchor" href="#pick-type-keys" aria-hidden="true">#</a> <code>Pick&lt;Type, Keys&gt;</code></h4><p>泛型工具类型 - <code>Pick&lt;Type, Keys&gt;</code> 从 Type 中选择一组属性来构造新类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token builtin">string</span>
    title<span class="token operator">:</span> <span class="token builtin">string</span>
    children<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">PickProps</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>Props<span class="token punctuation">,</span> <span class="token string">&#39;id&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;title&#39;</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>Pick 工具类型有两个类型变量：1 表示选择谁的属性 2 表示选择哪几个属性。</p></li><li><p>其中第二个类型变量，如果只选择一个则只传入该属性名即可。</p></li><li><p><strong>第二个类型变量传入的属性只能是第一个类型变量中存在的属性</strong>。</p></li><li><p>构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。</p></li></ol><h4 id="record-keys-type" tabindex="-1"><a class="header-anchor" href="#record-keys-type" aria-hidden="true">#</a> <code>Record&lt;Keys,Type&gt;</code></h4><p>泛型工具类型 - <code>Record&lt;Keys,Type&gt;</code> 构造一个对象类型，属性键为 Keys，属性类型为 Type。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">RecordObj</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">&#39;a&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;b&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> RecordObj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    c<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>Record 工具类型有两个类型变量：<strong>1 表示对象有哪些属性 2 表示对象属性的类型</strong>。</p></li><li><p>构建的新对象类型 RecordObj 表示：这个对象有三个属性分别为<code>a/b/c</code>，属性值的类型都是 <code>string[]</code>。</p></li></ol><h2 id="_4-5-索引签名类型" tabindex="-1"><a class="header-anchor" href="#_4-5-索引签名类型" aria-hidden="true">#</a> 4.5 索引签名类型</h2><p>绝大多数情况下，我们都可以在使用对象前就确定对象的结构，并为对象添加准确的类型。</p><p>使用场景：<strong>当无法确定对象中有哪些属性</strong>（或者说对象中可以出现任意多个属性），此时，就用到<strong>索引签名类型</strong>了。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">AnyObject</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj<span class="token operator">:</span> AnyObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>使用 <code>[key: string]</code> 来约束该接口中允许出现的属性名称。表示只要是 string 类型的属性名称，都可以出现在对象中。</p></li><li><p>这样，对象 obj 中就可以出现任意多个属性（比如，a、b 等）。</p></li><li><p><strong>key 只是一个占位符</strong>，可以换成任意合法的变量名称。</p></li><li><p>隐藏的前置知识：<strong>JS 中对象（{}）的键是 string 类型的</strong>。</p></li></ol><hr><p>在 JS 中数组是一类特殊的对象，特殊在<strong>数组的键（索引）是数值类型</strong>。</p><p>并且，数组也可以出现任意多个元素。所以，在数组对应的泛型接口中，也用到了索引签名类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">MyArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> arr<span class="token operator">:</span> MyArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><ol><li><p>MyArray 接口模拟原生的数组接口，并使用 <code>[n: number]</code> 来作为索引签名类型。</p></li><li><p>该索引签名类型表示：只要是 number 类型的键（索引）都可以出现在数组中，或者说数组中可以有任意多个元素。</p></li><li><p>同时也符合数组索引是 number 类型这一前提。</p></li></ol><h2 id="_4-6-映射类型" tabindex="-1"><a class="header-anchor" href="#_4-6-映射类型" aria-hidden="true">#</a> 4.6 映射类型</h2><p><strong>映射类型：基于旧类型创建新类型（对象类型）</strong>，减少重复、提升开发效率。</p><p>比如，类型 PropKeys 有 x/y/z，另一个类型 Type1 中也有 x/y/z，并且 Type1 中 x/y/z 的类型相同：</p><p><img src="`+N+'" alt=""></p><p>这样书写没错，但 x/y/z 重复书写了两次。像这种情况，就可以使用映射类型来进行简化。</p><p><img src="'+D+'" alt=""></p><p>解释：</p><ol><li><p>映射类型是<strong>基于索引签名类型</strong>的，所以，该语法类似于索引签名类型，也使用了 []。</p></li><li><p><code>Key in PropKeys</code> 表示 Key 可以是 PropKeys 联合类型中的任意一个，类似于 <code>forin(let k in obj)</code>。</p></li><li><p>使用映射类型创建的新对象类型 Type2 和类型 Type1 结构完全相同。</p></li><li><p>注意：<strong>映射类型只能在类型别名中使用，不能在接口中使用</strong></p></li></ol><hr><p>映射类型除了根据联合类型创建新类型外，还可以根据对象类型来创建：</p><p><img src="'+F+'" alt=""></p><p>解释：</p><ol><li><p>首先，先执行 keyof Props 获取到对象类型 Props 中所有键的联合类型即，<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code>。</p></li><li><p>然后，<code>Key in ...</code> 就表示 Key 可以是 Props 中所有的键名称中的任意一个。</p></li></ol><p><img src="'+j+'" alt=""></p><hr><p>实际上，前面讲到的泛型工具类型（比如，<code>Partial&lt;Type&gt;</code>）都是基于映射类型实现的。</p><p>比如，<code>Partial&lt;Type&gt;</code> 的实现：</p><p><img src="'+A+'" alt=""></p><p>解释：</p><ol><li><p><code>keyof T</code> 即 keyof Props 表示获取 Props 的所有键，也就是：<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code>。</p></li><li><p>在 [] 后面添加 ?（问号），表示将这些属性变为<strong>可选</strong>的，以此来实现 Partial 的功能。</p></li><li><p>冒号后面的 <code>T[P] 表示获取 T 中每个键对应的类型</code>。比如，如果是 &#39;a&#39; 则类型是 number；如果是 &#39;b&#39; 则类型是 string。</p></li><li><p>最终，新类型 PartialProps 和旧类型 Props 结构完全相同，只是让所有类型都变为可选了。</p></li></ol><hr><p>刚刚用到的 <strong>T[P]</strong> 语法，在 TS 中叫做<strong>索引查询（访问）类型</strong>。</p><p>作用：<strong>用来查询属性的类型</strong>。</p><p><img src="'+J+`" alt=""></p><p>解释：<code>Props[&#39;a&#39;]</code> 表示查询类型 Props 中属性 &#39;a&#39; 对应的类型 number。所以，TypeA 的类型为 number。</p><p>注意：<strong><code>[]</code>中的属性必须存在于被查询类型中</strong>，否则就会报错。</p><hr><p><strong>索引查询类型</strong>的其他使用方式：同时查询多个索引的类型</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Props</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
    c<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">TypeA</span> <span class="token operator">=</span> Props<span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span>	<span class="token comment">//string | number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：使用字符串字面量的联合类型，获取属性 a 和 b 对应的类型，结果为：<code> string | number</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">TypeA</span> <span class="token operator">=</span> Props<span class="token punctuation">[</span><span class="token keyword">keyof</span> Props<span class="token punctuation">]</span>	<span class="token comment">//string | number | boolean</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>解释：使用 keyof 操作符获取 Props 中所有键对应的类型，结果为：<code> string | number | boolean</code>。</p>`,242),O=[I];function z(M,E){return n(),a("div",null,O)}const q=s(C,[["render",z],["__file","04.html.vue"]]);export{q as default};
