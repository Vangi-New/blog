import{_ as n,o as s,c as a,a as e}from"./app-2be94d0d.js";const o="/assets/20231228153834-f1d39732.png",t="/assets/20231228154211-f4624764.png",p={},i=e(`<h2 id="模块化的基本概念" tabindex="-1"><a class="header-anchor" href="#模块化的基本概念" aria-hidden="true">#</a> 模块化的基本概念</h2><p><strong>模块化</strong>：是指解决一个复杂问题时，<strong>自顶向下逐层把系统划分成若干模块的过程</strong>。对于整个系统来说，模块是可组合、分解和更换的单元</p><p>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并<strong>互相依赖的</strong>多个小模块。 把代码进行模块化拆分的好处</p><ul><li>提高了代码的复用性</li><li>提高了代码的可维护性</li><li>可以实现按需加载</li></ul><p><strong>模块化规范</strong>：就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。例如使用什么样的语法格式来引用模块，在模块中使用什么样的语法格式向外暴露成员</p><p><strong>模块化规范的好处</strong>：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己</p><h2 id="node-js-中的模块化" tabindex="-1"><a class="header-anchor" href="#node-js-中的模块化" aria-hidden="true">#</a> Node.js 中的模块化</h2><h3 id="node-js-中模块的分类" tabindex="-1"><a class="header-anchor" href="#node-js-中模块的分类" aria-hidden="true">#</a> Node.js 中模块的分类</h3><p>Node.js 中根据模块来源的不同，将模块分为了 3 大类</p><ul><li><strong>内置模块</strong>（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</li><li><strong>自定义模块</strong>（用户创建的每个 .js 文件，都是自定义模块）</li><li><strong>第三方模块</strong>（由第三方开发出来的模块，使用前需要先下载）</li></ul><h3 id="加载模块" tabindex="-1"><a class="header-anchor" href="#加载模块" aria-hidden="true">#</a> 加载模块</h3><p>使用强大的 <code>require()</code>方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用</p><p>注意：使用 require() 方法加载其它模块时，会<strong>执行</strong>被加载模块中的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>							<span class="token comment">// 内置模块</span>
<span class="token keyword">const</span> custom <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./custom.js&#39;</span><span class="token punctuation">)</span>	<span class="token comment">// 自定义模块，需指明路径，可以省略 .js 的后缀名</span>
<span class="token keyword">const</span> moment <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;moment&#39;</span><span class="token punctuation">)</span>			<span class="token comment">// 第三方模块</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，不用.js后缀名也可以加载对应的文件。</p><h3 id="node-js-中的模块作用域" tabindex="-1"><a class="header-anchor" href="#node-js-中的模块作用域" aria-hidden="true">#</a> Node.js 中的模块作用域</h3><p><strong>模块作用域</strong>：和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制</p><p>模块作用域的好处：防止了全局变量污染的问题</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 模块作用域</span>
<span class="token keyword">const</span> username <span class="token operator">=</span> <span class="token string">&#39;张三&#39;</span>

<span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;大家好，我是&#39;</span> <span class="token operator">+</span> username<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> custom <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./模块作用域&#39;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>custom<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出是空对象，说明模块内定义的变量只能在模块内被访问。</p><h3 id="向外共享模块作用域中的成员" tabindex="-1"><a class="header-anchor" href="#向外共享模块作用域中的成员" aria-hidden="true">#</a> 向外共享模块作用域中的成员</h3><h4 id="module对象" tabindex="-1"><a class="header-anchor" href="#module对象" aria-hidden="true">#</a> <strong>module对象</strong></h4><p>在每个 .js 自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息</p><p><img src="`+o+`" alt=""></p><h4 id="module-exports-对象" tabindex="-1"><a class="header-anchor" href="#module-exports-对象" aria-hidden="true">#</a> <strong>module.exports 对象</strong></h4><ul><li>在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用</li><li>外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象，而一般默认该属性是{}即空对象。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在一个自定义模块中，默认情况下， module.exports = {}</span>

<span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">20</span>

<span class="token comment">// 向 module.exports 对象上挂载 username 属性</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">&#39;zs&#39;</span>
<span class="token comment">// 向 module.exports 对象上挂载 sayHello 方法</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Hello!&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token comment">//再共享出去</span>

<span class="token comment">// 让 module.exports 指向一个全新的对象</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">nickname</span><span class="token operator">:</span> <span class="token string">&#39;小黑&#39;</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Hi!&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="exports-和-module-exports-的使用误区" tabindex="-1"><a class="header-anchor" href="#exports-和-module-exports-的使用误区" aria-hidden="true">#</a> exports 和 module.exports 的使用误区</h4><ul><li><p>由于 <code>module.exports</code> 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 <code>exports</code> 对象。默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。</p></li><li><p>时刻谨记，require() 模块时，<strong>得到的永远是 module.exports 指向的对象</strong>，若出现exports 和 module.exports，最终不管exports怎么指向，都输出module.exports。注意挂载属性和指向新对象的区别。</p></li></ul><p><img src="`+t+`" alt=""></p><ul><li>注意：为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在一个自定义模块中，默认情况下， module.exports = {}</span>

<span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">20</span>

<span class="token comment">// 向 module.exports 对象上挂载 username 属性</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token string">&#39;zs&#39;</span>
<span class="token comment">// 向 module.exports 对象上挂载 sayHello 方法</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Hello!&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>age <span class="token operator">=</span> age

<span class="token comment">// 让 module.exports 指向一个全新的对象 </span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">nickname</span><span class="token operator">:</span> <span class="token string">&#39;小黑&#39;</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Hi!&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在外界使用 require 导入一个自定义模块的时候，得到的成员，</span>
<span class="token comment">// 就是 那个模块中，通过 module.exports 指向的那个对象</span>
<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./11.自定义模块&#39;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="node-js-中的模块化规范" tabindex="-1"><a class="header-anchor" href="#node-js-中的模块化规范" aria-hidden="true">#</a> Node.js 中的模块化规范</h3><p>Node.js 遵循了 <strong>CommonJS</strong> 模块化规范，CommonJS 规定了<strong>模块的特性</strong>和<strong>各模块之间如何相互依赖</strong></p><ul><li>每个模块内部，module 变量代表当前模块</li><li>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口</li><li>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块</li></ul><h2 id="模块的加载机制" tabindex="-1"><a class="header-anchor" href="#模块的加载机制" aria-hidden="true">#</a> 模块的加载机制</h2><p>模块在第一次加载后会被缓存，多次调用 <strong>require()</strong> 模块的代码只会被执行一次。不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p><h4 id="内置模块的加载机制" tabindex="-1"><a class="header-anchor" href="#内置模块的加载机制" aria-hidden="true">#</a> 内置模块的加载机制</h4><ul><li>内置模块的加载优先级最高（当第三方模块和内置模块同名时）</li></ul><h4 id="自定义模块的加载机制" tabindex="-1"><a class="header-anchor" href="#自定义模块的加载机制" aria-hidden="true">#</a> 自定义模块的加载机制</h4><ul><li>使用 <code>require()</code> 加载自定义模块时，必须指定以 <code>./</code> 或 <code>…/</code> 开头的路径标识符。在加载自定义模块时，如果没有指定 <code>./</code> 或 <code>…/</code> 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</li><li>在使用 require() 导入自定义模块时，如果省略了文件的扩展名，Node.js 会按顺序分别尝试加载以下的文件 <ol><li>按照确切的文件名进行加载</li><li>补全 .js 扩展名进行加载</li><li>补全 .json 扩展名进行加载</li><li>补全 .node 扩展名进行加载</li><li>加载失败，终端报错</li></ol></li></ul><h4 id="第三方模块的加载机制" tabindex="-1"><a class="header-anchor" href="#第三方模块的加载机制" aria-hidden="true">#</a> 第三方模块的加载机制</h4><ul><li>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 <code>./</code> 或 <code>…/</code> 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块</li><li>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</li><li>假设在 <code>‘C:\\Users\\itheima\\project\\node_modules\\a.js’</code> 里调用 <code>require(‘tools’)</code>，Node.js 会按以下顺序查找 <ol><li><code>C:\\Users\\itheima\\project\\node_modules\\tools</code></li><li><code>C:\\Users\\itheima\\node_modules\\tools</code></li><li><code>C:\\Users\\node_modules\\tools</code></li><li><code>C:\\node_modules\\tools</code></li><li>报错</li></ol></li></ul><h4 id="目录作为模块" tabindex="-1"><a class="header-anchor" href="#目录作为模块" aria-hidden="true">#</a> 目录作为模块</h4><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式</p><ol><li>在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性值作为 require() 加载的入口</li><li>如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件</li><li>如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：<code>Error: Cannot find module ‘xxx’</code></li></ol>`,48),l=[i];function c(r,d){return s(),a("div",null,l)}const m=n(p,[["render",c],["__file","04-mokuaihua.html.vue"]]);export{m as default};
