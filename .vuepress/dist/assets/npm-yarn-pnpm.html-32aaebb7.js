import{_ as o,r as a,o as p,c as d,b as t,e as n,d as s,a as r}from"./app-f6e46239.js";const l="/assets/20231229143059-f8bb9d46.png",i="/assets/20240219153926-6ceb929a.png",c={},h=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"前言"),t("p",null,"在前端工程化的背景下，依赖管理越来越得到重视，在开发的时候经常会接触到各种包管理工具，也会经常用到npm, yarn, pnpm等等指令，这篇文章主要是讲一讲这些概念之间的区别。")],-1),g=t("h2",{id:"npm",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#npm","aria-hidden":"true"},"#"),n(" npm")],-1),m={href:"https://link.juejin.cn/?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3DNode%26spm%3D1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},u=r('<h3 id="npm-v2" tabindex="-1"><a class="header-anchor" href="#npm-v2" aria-hidden="true">#</a> npm v2</h3><p>特性 ：采用简单的<strong>递归安装</strong>方法，将每个模块的依赖安装到自身的node_modules文件夹中，形成一个<strong>高度嵌套</strong>的依赖树。</p><p>可能存在的问题 ：</p><ol><li><p>项目规模比较大时，容易出现重复依赖，互相依赖，嵌套地狱等问题。</p></li><li><p>大量的重复依赖安装，造成空间资源的大量浪费，同时也会造成依赖安装时间过长（体积大，安装慢）。</p></li><li><p>由于嵌套层级过深会导致文件路径过长，在windows系统中可能会引发错误。 windows 文件系统中，文件路径不能超过 260 个字符长度。</p></li></ol><h3 id="npm-v3" tabindex="-1"><a class="header-anchor" href="#npm-v3" aria-hidden="true">#</a> npm v3</h3><p>特性 ：v3版本作了较大的更新，采取了<strong>扁平化</strong>的依赖结构。</p><p>可能存在的问题 ：</p>',7),k={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm%2Fissues%2F8826",target:"_blank",rel:"noopener noreferrer"},_=r('<blockquote><p>npm@3 is sometimes slower than npm@2, though this is highly tree dependent. It is doing more, but all the same, folks&#39;d like it to be as fast as it can be. Profiling would be grand. 😉 This ticket exists as the tracker for npm@3 performance.</p></blockquote><h3 id="npm-v5" tabindex="-1"><a class="header-anchor" href="#npm-v5" aria-hidden="true">#</a> npm v5</h3><p>特性 ：引入了<strong>package-lock.json</strong>机制，保证了依赖安装的确定性。package-lock.json 的作用是锁定项目的依赖结构，理论上只要项目中存在 package-lock.json 文件，每次执行 npm install 后生成的node_modules 目录结构一定是完全相同的。</p><p>其实在package-lock.json机制出现之前，可以通过<strong>npm-shrinkwrap</strong>实现锁定依赖结构，但是npm-shrinkwrap的默认关闭的，需要主动执行。</p><h4 id="什么是语义版本控制-semver" tabindex="-1"><a class="header-anchor" href="#什么是语义版本控制-semver" aria-hidden="true">#</a> <strong>什么是语义版本控制（semver）？</strong></h4>',5),v={href:"https://link.juejin.cn/?target=http%3A%2F%2Fsemver.org%2F",target:"_blank",rel:"noopener noreferrer"},f=r(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;@types/react&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;^18.0.12&quot;</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的 <strong>^</strong> 表示指定的 MAJOR 版本号下, 所有更新的版本。这里会安装18.x.x的任意最新版本。</p>`,2),b=t("strong",null,"MAJOR",-1),x=t("strong",null,"MINOR",-1),j=t("strong",null,"PATCH",-1),y={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fabout-semantic-versioning",target:"_blank",rel:"noopener noreferrer"},F=t("p",null,[t("img",{src:l,alt:""})],-1),w=t("p",null,"从这里我们知道，即使是相同的package.json，每次安装的依赖并不都是完全一样的。这可能会导致一些问题。",-1),q=t("h4",{id:"为什么要引入-lockfiles-在npm中即为package-lock-json",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#为什么要引入-lockfiles-在npm中即为package-lock-json","aria-hidden":"true"},"#"),n(),t("strong",null,"为什么要引入 lockfiles？ 在npm中即为package-lock.json")],-1),N=t("p",null,[n("因为单一的 "),t("code",null,"package.json"),n(" 不能确定唯一的依赖树。 主要原因有两点：")],-1),A=t("li",null,[t("p",null,"不同版本的npm的安装依赖的策略和算法可能是不一样的。")],-1),M={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv6%2Fusing-npm%2Fsemver",target:"_blank",rel:"noopener noreferrer"},P=t("strong",null,"npm install",-1),B=t("code",null,"package.json",-1),I={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv6%2Fusing-npm%2Fsemver",target:"_blank",rel:"noopener noreferrer"},T=r('<p>因此, <strong>保证能够完整准确的还原项目依赖</strong> 就是<strong>lockfiles</strong>出现的原因。</p><h4 id="配置了package-lock-json-就一定会生效吗" tabindex="-1"><a class="header-anchor" href="#配置了package-lock-json-就一定会生效吗" aria-hidden="true">#</a> <strong>配置了package-lock.json，就一定会生效吗？</strong></h4><p><strong>不一定</strong>。</p><p>主要取决于npm版本以及 package-lock.json 和 package.json 之间的兼容关系。</p><table><thead><tr><th><strong>版本</strong></th><th style="text-align:left;"><strong>方案</strong></th></tr></thead><tbody><tr><td>NPM v5.0.x</td><td style="text-align:left;">依据 package-lock.json 安装依赖</td></tr><tr><td>NPM v5.1.0 - v5.4.2</td><td style="text-align:left;">如果package.json中声明的依赖版本规范有符合的更新的版本的时候，会忽略package-lock.json，按照package.json 安装依赖，并更新 package-lock.json</td></tr><tr><td>NPM &gt;v5.4.2</td><td style="text-align:left;">如果package.json中声明的依赖版本规范和package.lock.json中声明的依赖版本兼容，则依据package-lock.json 安装依赖；如果不兼容，按照package.json 安装依赖，并更新 package-lock.json</td></tr></tbody></table><h2 id="yarn" tabindex="-1"><a class="header-anchor" href="#yarn" aria-hidden="true">#</a> yarn</h2><p>yarn的出现解决了npm存在的一些比较严重的问题，主要是依赖的<strong>确定性</strong>，<strong>完整性</strong>，<strong>依赖安装速度</strong>等等。</p><p>这里要注意的是，yarn的出现是在2016年，此时 npm 处于 v3 时期，之后npm的更新也在不断实现yarn所拥有的一部分优点。这里所说的yarn的优点主要是针对早期的npm而言。</p><h3 id="yarn的优点" tabindex="-1"><a class="header-anchor" href="#yarn的优点" aria-hidden="true">#</a> yarn的优点</h3><ul><li><p><strong>速度快</strong> yarn的速度快是其特性共同表现出来的优点。</p></li><li><p><strong>依赖的确定性。</strong> 通过yarn.lock等机制，可以锁定依赖的版本，保证相同的依赖关系所安装的依赖是一致的。（npm v5中提出了package-lock.json实现相同的功能）</p></li><li><p><strong>扁平化依赖结构，减少依赖的冗余。</strong> yarn实现了扁平化依赖结构，避免了相同的依赖被重复安装，减小体积，加快安装速度。（npm v3中也做了相同的优化）</p></li><li><p><strong>网络性能更好</strong> 采用了请求排队的理念,类似于并发池连接,利用并行下载以最大化网络资源利用率;同时也引入了一种安装失败的重试机制。</p></li><li><p><strong>实现了离线模式</strong> 通过缓存机制，实现了离线模式。可以让 Yarn 在网络出现故障的情况下仍然能正常工作。（npm也具有缓存机制）</p></li></ul><h2 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> pnpm</h2>',11),V={href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.pnpm.cn%2Fmotivation",target:"_blank",rel:"noopener noreferrer"},C=r('<h3 id="pnpm的优点" tabindex="-1"><a class="header-anchor" href="#pnpm的优点" aria-hidden="true">#</a> pnpm的优点</h3><ol><li>速度非常快，超过了npm和yarn</li><li>pnpm继承了yarn的所有优点，包括离线模式和确定性安装。</li></ol><h3 id="pnpm的不同点" tabindex="-1"><a class="header-anchor" href="#pnpm的不同点" aria-hidden="true">#</a> pnpm的不同点</h3><ol><li><strong>利用硬链接和符号链接来避免复制所有本地缓存源文件</strong>，从而节省磁盘空间并提升安装速度。</li><li><strong>非扁平的 node_modules 目录。</strong></li></ol><h2 id="npm-pnpm-yarn-比较" tabindex="-1"><a class="header-anchor" href="#npm-pnpm-yarn-比较" aria-hidden="true">#</a> npm, pnpm, yarn 比较</h2><table><thead><tr><th><strong>特性</strong></th><th style="text-align:left;">npm 2.X</th><th><strong>npm 3.X</strong></th><th>npm 5.X</th><th><strong>yarn</strong></th><th><strong>pnpm</strong></th></tr></thead><tbody><tr><td>速度</td><td style="text-align:left;">慢</td><td>慢</td><td>较快</td><td>快</td><td>非常快</td></tr><tr><td>依赖共享</td><td style="text-align:left;">否</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>嵌套化依赖</td><td style="text-align:left;">✅</td><td></td><td></td><td></td><td>✅</td></tr><tr><td>扁平化依赖</td><td style="text-align:left;"></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr><tr><td>锁定依赖结构</td><td style="text-align:left;"></td><td></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>package-lock.json</td><td style="text-align:left;"></td><td></td><td>✅</td><td></td><td></td></tr><tr><td>yarn.lock</td><td style="text-align:left;"></td><td></td><td></td><td>✅</td><td></td></tr><tr><td>离线安装</td><td style="text-align:left;"></td><td></td><td></td><td>✅</td><td>✅</td></tr></tbody></table><p>简单点来说，</p><ol><li>npm和yarn实现的都是<strong>项目级别</strong>的依赖去重，项目和项目之间可能还具有大量相同的依赖。100个项目就对应100份依赖文件，这些依赖可能有大量的重复依赖，从而占用了大量的硬盘资源。</li><li>pnpm实现的是<strong>机器级别</strong>的依赖去重，所有文件都保存在硬盘上的统一的位置。通过硬连接，项目之间方便地共享相同版本的依赖包。 以项目和依赖包的比例来看，节省了大量的硬盘空间， 并且安装速度也大大提高了！</li></ol><h2 id="一些记录" tabindex="-1"><a class="header-anchor" href="#一些记录" aria-hidden="true">#</a> 一些记录</h2>',9),E={href:"https://juejin.cn/post/6844903535117598733",target:"_blank",rel:"noopener noreferrer"},L={href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.lernajs.cn%2F",target:"_blank",rel:"noopener noreferrer"},O=r('<p><img src="'+i+`" alt=""></p><p>好像还有几个比较像的指令，<strong>npx, cnpm</strong>,也顺便提一下好了。</p><p><code>npx</code>, <code>cnpm</code>都不是包管理工具。</p><h3 id="npx" tabindex="-1"><a class="header-anchor" href="#npx" aria-hidden="true">#</a> <strong>npx</strong></h3><p><code>npx</code>是<code>npm</code>内置的一个命令，可以用来执行二进制文件。比如之前主要是通过<code>npm scripts</code>来执行二进制文件，有了<code>npx</code>指令之后，可以直接在<code>npx</code> 后 加上需要执行的二进制文件。</p><p>举个栗子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token string-property property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;serve&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vue-cli-service serve&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般情况，我们通过 <code>npm run serve</code> 启动项目，本质上还是运行 <code>vue-cli-service serve</code> 有了npx之后，可以直接执行 <code>npx vue-cli-service serve</code></p><h3 id="cnpm" tabindex="-1"><a class="header-anchor" href="#cnpm" aria-hidden="true">#</a> <strong>cnpm</strong></h3><p>cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。</p><p>为了解决npm服务器在国外而产生的网速慢，连接不稳定的问题，淘宝团队建立了npm在国内的镜像服务器，通过cnpm指令来连接。</p><blockquote><p>cnpm官网：“这是一个完整 npmjs.org镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p></blockquote><p>安装的命令为：</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>当然也可以继续使用npm，把源替换成淘宝的镜像。</p><p>临时：<code>npm --registry https://registry.npm.taobao.org install express</code></p><p>永久：<code>npm config set registry https://registry.npm.taobao.org</code></p>`,17);function R(X,D){const e=a("ExternalLinkIcon");return p(),d("div",null,[h,g,t("p",null,[n("NPM（Node Package Managemnt）为Node创造了一个强大且丰富的生态，是"),t("a",m,[n("Node.js"),s(e)]),n("能够如此成功的主要原因之一。npm也是node.js内置的包管理器，和node一并安装。我们可以从npm的发展历程来看其的特性变化。")]),u,t("ol",null,[t("li",null,[n("采取扁平化的结构可以解决上述的问题。但是也会存在新的问题。为了生成扁平化的依赖树，npm需要遍历项目中的所有依赖关系，构建完整的依赖关系树，这是一个比较耗时的操作，所以也会造成依赖安装时间过长。这个是github上npm仓库中的一个"),t("a",k,[n("issue"),s(e)]),n("对此的描述")])]),_,t("p",null,[n("在了解为什么要引入锁定依赖结构的机制之前，我们需要了解npm的"),t("a",v,[n("语义版本控制（semver）"),s(e)]),n("。简单来说，npm包的版本描述并不是绝对精确的，而是包含一定语义（可变化）。我们可能会遇到形如这样的版本号。")]),f,t("p",null,[n("npm包的版本规范为"),b,n("."),x,n("."),j,n("。官网原文描述请"),t("a",y,[n("点击"),s(e)]),n("，不同的符号含义如下图所示。")]),F,w,q,N,t("ol",null,[A,t("li",null,[t("p",null,[n("就是上面提到的 "),t("a",M,[n("semver-range version"),s(e)]),n("。"),P,n(" 将根据 "),B,n(" 中的 "),t("a",I,[n("semver-range version"),s(e)]),n(" 更新依赖，如果某些依赖更新了，就可能会导致安装的依赖不同。")])])]),T,t("p",null,[n("pnpm是一个比较新的包管理工具，虽然比较新，但是热度还是挺高的。 这个是pnpm官网的"),t("a",V,[n("描述"),s(e)]),n("。")]),C,t("p",null,[n("在了解npm, yarn, pnpm的时候，又发现了新的东西比如"),t("a",E,[n("Turbo"),s(e)]),n("和"),t("a",L,[n("Lerna"),s(e)]),n("，还有一张有意思的图片（来源于参考文章）。")]),O])}const Y=o(c,[["render",R],["__file","npm-yarn-pnpm.html.vue"]]);export{Y as default};
