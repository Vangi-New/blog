import{_ as c,r as d,o as n,c as t,b as a,e,d as i,a as o}from"./app-f6e46239.js";const s={},p=o(`<h2 id="docker-registry" tabindex="-1"><a class="header-anchor" href="#docker-registry" aria-hidden="true">#</a> docker registry</h2><p>我们可以使用<code>docker push</code>将自己的image推送到docker hub中进行共享，但是在实际工作中，很多公司的代码不能上传到公开的仓库中，因此我们可以创建自己的镜像仓库。</p><p>docker 官网提供了一个docker registry的私有仓库项目，可以方便的通过docker部署。</p><p><code>docker run -d -p 5000:5000 --restart always --name registry registry:2</code></p><p><code>docker image tag ruoyi-java:4.7.4 localhost:5000/ruoyi-java:4.7.4</code></p><p><code>docker push localhost:5000/ruoyi-java:4.7.4</code></p><p><code>docker pull localhost:5000/ruoyi-java:4.7.4</code></p><p>如果遇到以下错误：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28915315/1663307599499-8035dfa9-01e1-44dd-8d96-e27c52ea0a57.png" alt="img"></p><p>这是因为<code>docker push</code>默认使用<code>HTTPS</code>协议，而服务端的<code>registry</code>仓库使用的是<code>HTTP</code>。</p><p>解决这个问题，需要修改/etc/docker/daemon.json，加入</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&quot;insecure-registries&quot;: [&quot;192.168.56.108:5000&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="harbor" tabindex="-1"><a class="header-anchor" href="#harbor" aria-hidden="true">#</a> harbor</h2><p>habor是一个功能更强大镜像仓库，它具有完整的权限控制和Web界面，更符合我们的实际工作场景。</p><p>下载bitname发布的harbor镜像配置包：https://github.com/bitnami/containers/archive/main.tar.gz</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> harbor
<span class="token function">tar</span> xzvf containers-main.tar.gz
<span class="token builtin class-name">cd</span> containers-main/bitnami/harbor-portal
<span class="token function">docker</span> compose up <span class="token parameter variable">-d</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16),l={href:"http://192.168.56.108/harbor/projects",target:"_blank",rel:"noopener noreferrer"},h=a("code",null,"admin/bitnami",-1),m=o('<p><img src="https://cdn.nlark.com/yuque/0/2022/png/28915315/1663308776828-c8e2eb02-b689-4f47-9243-83a1a1cb5f41.png" alt="img"></p><h2 id="保存与加载image" tabindex="-1"><a class="header-anchor" href="#保存与加载image" aria-hidden="true">#</a> 保存与加载image</h2><p>当我们处于离线状态，比如在很多内网上不能访问互联网，这时候不能通过镜像仓库的方式共享image，我们可以使用导出和导入功能，手动拷贝镜像。</p><p><code>docker save</code>会包含所有层，以及所有标签 + 版本信息。</p><p><code>docker save alpine:3.15 &gt; alpine-3.15.tar </code> 保存image</p><p><code>docker rmi alpine:3.15</code> 删除本地image</p><p><code>docker load &lt; alpine-3.15.tar</code> 加载image</p><blockquote><p>注意：</p><p>不要跟export和import命令混淆</p><p><code>docker save/load IMAGE</code> save和load操作的是镜像</p><p><code>docker export/import CONTAINER</code>export和import操作对象是容器</p><p>image包含多个层，每一层都不可变，save保存的信息包含每个层和所有标签 + 版本信息。</p><p>容器运行的时候会创建一个可写入的容器层，所有的更改都写入容器层，export导出的只有容器层，不包含父层和标签信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28915315/1661007394206-b7d81707-a557-41e8-a840-f708acf20292.png" alt="img"></p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2></blockquote>',8);function u(g,b){const r=d("ExternalLinkIcon");return n(),t("div",null,[p,a("p",null,[e("浏览器访问："),a("a",l,[e("http://192.168.56.108"),i(r)]),e("，默认用户名/密码："),h]),m])}const v=c(s,[["render",u],["__file","09.html.vue"]]);export{v as default};
