import{_ as s,o as n,c as p,a as t}from"./app-c9e63f9e.js";const o="/assets/20231215152340-0635d7be.png",r="/assets/20231215152456-fb81297a.png",a="/assets/20231215153021-49748abe.png",e="/assets/20231215153150-3add2afc.png",i="/assets/20231215153226-118aa359.png",l="/assets/20231215154114-25c7c9d5.png",c="/assets/20231218104401-0dcf47fc.png",g="/assets/20231218104513-2536440c.png",d="/assets/20231218104650-a0ff1d38.png",h="/assets/20231218104750-07d6fa46.png",_="/assets/20231218105710-4e695bd7.png",m="/assets/20231218105911-c6e6d23d.png",u="/assets/20231218110023-6ddc4c2f.png",f="/assets/20231218115444-9326eaa1.png",b="/assets/20231218120113-2cc19b56.png",S="/assets/20231218120133-793f3659.png",y="/assets/20231218120533-23eaa839.png",T="/assets/20231218120623-ba825d0f.png",v="/assets/20231218144043-7271c9f1.png",k="/assets/20231218144221-4b0e2c81.png",x="/assets/20231218144336-7cf9adf1.png",J="/assets/20231218144422-4d93d788.png",D="/assets/20231218144505-3a400d5f.png",H="/assets/20231218165518-906da46a.png",E="/assets/20231219104958-8e720fd9.png",P="/assets/20231219105103-24fca543.png",L="/assets/20231219105212-2307758e.png",w="/assets/20231219105315-69c897e4.png",M="/assets/20231219105605-4b8d8753.png",U="/assets/20231221104839-bea79398.png",A="/assets/20231221105105-de596ab5.png",B={},I=t('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong>。</p><ul><li><p>所有的 JS 代码都是 TS 代码。</p></li><li><p>JS 有类型（比如，number/string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>。而 <strong>TS 会检查</strong>。</p></li></ul><p>TypeScript 类型系统的主要优势：可以<strong>显示标记出代码中的意外行为</strong>，从而降低了发生错误的可能性。</p><ol><li><p>类型注解</p></li><li><p>常用基础类型</p></li></ol><h2 id="_3-1-类型注解" tabindex="-1"><a class="header-anchor" href="#_3-1-类型注解" aria-hidden="true">#</a> 3.1 类型注解</h2><p>示例代码：</p><p><img src="'+o+'" alt=""></p><p>说明：代码中的 : <strong>number</strong> 就是类型注解。</p><p>作用：为变量<strong>添加类型约束</strong>。比如，上述代码中，约定变量 age 的类型为 number（数值类型）。</p><p>解释：<strong>约定了什么类型，就只能给变量赋值该类型的值</strong>，否则，就会报错。</p><p><img src="'+r+'" alt=""></p><h2 id="_3-2-常用基础类型概述" tabindex="-1"><a class="header-anchor" href="#_3-2-常用基础类型概述" aria-hidden="true">#</a> 3.2 常用基础类型概述</h2><p>可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型。</p><ol><li><p>JS 已有类型</p><ul><li>原始类型：<code>number/string/boolean/null/undefined/symbol</code>。</li><li>对象类型：<code>object</code>（包括，数组、对象、函数等对象）。</li></ul></li><li><p>TS 新增类型</p><ul><li>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、<code>void</code>、<code>any</code> 等。</li></ul></li></ol><h2 id="_3-3-原始类型" tabindex="-1"><a class="header-anchor" href="#_3-3-原始类型" aria-hidden="true">#</a> 3.3 原始类型</h2><p>原始类型：<code>number/string/boolean/null/undefined/symbol</code>。</p><p>特点：<strong>简单</strong>。这些类型，完全按照 JS 中类型的名称来书写。</p><p><img src="'+a+'" alt=""></p><h2 id="_3-4-数组类型" tabindex="-1"><a class="header-anchor" href="#_3-4-数组类型" aria-hidden="true">#</a> 3.4 数组类型</h2><p>对象类型：object（包括，数组、对象、函数等对象）。</p><p>特点：对象类型，在 TS 中更加细化，<strong>每个具体的对象都有自己的类型语法</strong>。</p><p><strong>数组类型</strong>的两种写法：（推荐使用 <code>number[]</code> 写法）</p><p><img src="'+e+'" alt=""></p><p>需求：数组中既有 <code>number</code> 类型，又有 <code>string</code> 类型，这个数组的类型应该如何写？</p><p><img src="'+i+'" alt=""></p><p>解释：<code>|</code> （竖线）在 TS 中叫做联合类型（由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种）。</p><p>注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（<code>||</code>）混淆了。</p><h2 id="_3-5-类型别名" tabindex="-1"><a class="header-anchor" href="#_3-5-类型别名" aria-hidden="true">#</a> 3.5 类型别名</h2><p><strong>类型别名</strong>（自定义类型）：为任意类型起别名。</p><p>使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，<strong>简化该类型的使用</strong>。</p><p><img src="'+l+'" alt=""></p><p>解释：</p><ol><li><p>使用 <strong>type</strong> 关键字来创建类型别名。</p></li><li><p>类型别名（比如，此处的 CustomArray），可以是任意合法的变量名称。</p></li><li><p>创建类型别名后，直接<strong>使用该类型别名作为变量的类型注解</strong>即可。</p></li></ol><h2 id="_3-6-函数类型" tabindex="-1"><a class="header-anchor" href="#_3-6-函数类型" aria-hidden="true">#</a> 3.6 函数类型</h2><p>函数的类型实际上指的是：函数<strong>参数</strong>和<strong>返回值</strong>的类型。</p><p>为函数指定类型的两种方式：1 单独指定参数、返回值的类型 2 同时指定参数、返回值的类型。</p><ol><li>单独指定参数、返回值的类型：</li></ol><p><img src="'+c+'" alt=""></p><ol start="2"><li>同时指定参数、返回值的类型：</li></ol><p><img src="'+g+'" alt=""></p><p>解释：当函数作为表达式时，可以通过<strong>类似箭头函数形式的语法</strong>来为函数添加类型。</p><p>注意：这种形式只适用于函数表达式。</p><ol start="3"><li>如果函数没有返回值，那么，函数返回值类型为：<strong>void</strong>。</li></ol><p><img src="'+d+'" alt=""></p><ol start="4"><li>可选参数</li></ol><p>使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到可选参数了。</p><p>比如，数组的 slice 方法，可以 slice() 也可以 slice(1) 还可以 slice(1, 3)。</p><p><img src="'+h+'" alt=""></p><p>可选参数：在可传可不传的参数名称后面添加 ?（问号）。</p><p>注意：<strong>可选参数只能出现在参数列表的最后</strong>，也就是说可选参数后面不能再出现必选参数。</p><h2 id="_3-7-对象类型" tabindex="-1"><a class="header-anchor" href="#_3-7-对象类型" aria-hidden="true">#</a> 3.7 对象类型</h2><p>JS 中的对象是由属性和方法构成的，而 TS 中<strong>对象的类型</strong>就是在<strong>描述对象的结构</strong>（有什么类型的属性和方法）。</p><p>对象类型的写法：</p><p><img src="'+_+'" alt=""></p><p>解释：</p><ol><li>直接使用 {} 来描述对象结构。属性采用属性名: 类型的形式；方法采用方法名(): 返回值类型的形式。</li><li>如果方法有参数，就在方法名后面的小括号中指定参数类型（比如：greet(name: string): void）。</li><li>在一行代码中指定对象的多个属性类型时，使用 ;（分号）来分隔。 <ul><li>如果一行代码只指定一个属性类型（通过换行来分隔多个属性类型），可以去掉 ;（分号）。</li><li>方法的类型也可以使用箭头函数形式（比如：{ sayHi: () =&gt; void }）。</li></ul></li></ol><hr><p>对象的属性或方法，也可以是可选的，此时就用到<strong>可选属性</strong>了。</p><p>比如，我们在使用 axios({ … }) 时，如果发送 GET 请求，method 属性就可以省略。</p><p><img src="'+m+'" alt=""></p><p><strong>可选属性</strong>的语法与函数可选参数的语法一致，都使用 <strong>?</strong>（问号）来表示。</p><h2 id="_3-8-接口" tabindex="-1"><a class="header-anchor" href="#_3-8-接口" aria-hidden="true">#</a> 3.8 接口</h2><p>当一个对象类型被多次使用时，一般会使用**接口（interface）**来描述对象的类型，达到复用的目的。</p><p><img src="'+u+'" alt=""></p><p>解释：</p><ol><li>使用 interface 关键字来声明接口。</li><li>接口名称（比如，此处的 IPerson），可以是任意合法的变量名称。</li><li>声明接口后，直接使用接口名称作为变量的类型。</li><li>因为每一行只有一个属性类型，因此，属性类型后没有 ;（分号）。</li></ol><hr><p>interface（接口）和 type（类型别名）的对比：</p><p><img src="'+f+'" alt=""></p><ul><li>相同点： <ul><li>都可以给对象指定类型。</li></ul></li><li>不同点： <ul><li>接口，只能为对象指定类型。</li><li>类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名。</li></ul></li></ul><hr><p>如果两个接口之间有相同的属性或方法，可以<strong>将公共的属性或方法抽离出来，通过继承来实现复用</strong>。</p><p>比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐。</p><p><img src="'+b+'" alt=""></p><p>更好的方式：</p><p><img src="'+S+'" alt=""></p><p>解释：</p><ol><li>使用 extends（继承）关键字实现了接口 Point3D 继承 Point2D。</li><li>继承后，Point3D 就有了 Point2D 的所有属性和方法（此时，Point3D 同时有 x、y、z 三个属性）。</li></ol><h2 id="_3-9-元组" tabindex="-1"><a class="header-anchor" href="#_3-9-元组" aria-hidden="true">#</a> 3.9 元组</h2><p>场景：在地图中，使用经纬度坐标来标记位置信息。</p><p>可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型。</p><p><img src="'+y+'" alt=""></p><p>使用 <code>number[]</code> 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字。</p><p>更好的方式：<strong>元组（Tuple）</strong>。</p><p>元组类型是另一种类型的数组，它<strong>确切地知道包含多少个元素，以及特定索引对应的类型</strong>。</p><p><img src="'+T+'" alt=""></p><p>解释：</p><ol><li>元组类型可以确切地标记出有多少个元素，以及每个元素的类型。</li><li>该示例中，元素有两个元素，每个元素的类型都是 number。</li></ol><h2 id="_3-10-类型推论" tabindex="-1"><a class="header-anchor" href="#_3-10-类型推论" aria-hidden="true">#</a> 3.10 类型推论</h2><p>在 TS 中，某些没有明确指出类型的地方，TS 的<strong>类型推论机制会帮助提供类型</strong>。</p><p>换句话说：由于类型推论的存在，这些地方，类型注解可以<strong>省略</strong>不写！</p><p>发生类型推论的 2 种常见场景：1 声明变量并初始化时 2 决定函数返回值时。</p><p><img src="'+v+'" alt=""></p><p>注意：这两种情况下，类型注解可以省略不写！</p><p>推荐：<strong>能省略类型注解的地方就省略</strong>（<s>偷懒</s>，充分利用TS类型推论的能力，提升开发效率）。</p><p>技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型。</p><h2 id="_3-11-类型断言" tabindex="-1"><a class="header-anchor" href="#_3-11-类型断言" aria-hidden="true">#</a> 3.11 类型断言</h2><p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。</p><p>比如，</p><p><img src="'+k+'" alt=""></p><p>注意：<code>getElementById</code> 方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性。</p><p>因此，这个类型<strong>太宽泛（不具体）</strong>，无法操作 href 等 a 标签特有的属性或方法。</p><p>解决方式：这种情况下就需要<strong>使用类型断言指定更加具体的类型</strong>。</p><hr><p>使用类型断言：</p><p><img src="'+x+'" alt=""></p><p>解释：</p><ol><li>使用 as 关键字实现类型断言。</li><li>关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）。</li><li>通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了。</li></ol><hr><p>另一种语法，使用 &lt;&gt; 语法，这种语法形式不常用知道即可：</p><p><img src="'+J+'" alt=""></p><p>技巧：在浏览器控制台，通过 console.dir() 打印 DOM 元素，在属性列表的最后面，即可看到该元素的类型。</p><h2 id="_3-12-字面量类型" tabindex="-1"><a class="header-anchor" href="#_3-12-字面量类型" aria-hidden="true">#</a> 3.12 字面量类型</h2><p>思考以下代码，两个变量的类型分别是什么？</p><p><img src="'+D+'" alt=""></p><p>通过 TS 类型推论机制，可以得到答案：</p><ol><li>变量 str1 的类型为：<strong>string</strong>。</li><li>变量 str2 的类型为：<strong>&#39;Hello TS&#39;</strong>。</li></ol><p>解释：</p><ol><li>str1 是一个变量（let），它的值可以是任意字符串，所以类型为：<strong>string</strong>。</li><li>str2 是一个常量（const），它的值不能变化只能是 <strong>&#39;Hello TS&#39;</strong>，所以，它的类型为：<strong>&#39;Hello TS&#39;</strong>。</li></ol><p>注意：此处的 <strong>&#39;Hello TS&#39;</strong>，就是一个<strong>字面量类型</strong>。也就是说<strong>某个特定的字符串也可以作为 TS 中的类型</strong>。</p><p>除字符串外，任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用。</p><hr><p>使用模式：<strong>字面量类型配合联合类型一起使用</strong>。</p><p>使用场景：用来<strong>表示一组明确的可选值列表</strong>。</p><p>比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个。</p><p><img src="'+H+'" alt=""></p><p>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个。</p><p>优势：相比于 string 类型，使用字面量类型更加精确、严谨。</p><h2 id="_3-13-枚举" tabindex="-1"><a class="header-anchor" href="#_3-13-枚举" aria-hidden="true">#</a> 3.13 枚举</h2><p>枚举的功能类似于<strong>字面量类型+联合类型</strong>组合的功能，也可以表示<strong>一组明确的可选值</strong>。</p><p><strong>枚举：定义一组命名常量</strong>。它描述一个值，该值可以是这些命名常量中的一个。</p><p><img src="'+E+'" alt=""></p><p>解释：</p><ol><li>使用 <code>enum</code> 关键字定义枚举。</li><li>约定枚举名称、枚举中的值以大写字母开头。</li><li>枚举中的多个值之间通过 ,（逗号）分隔。</li><li>定义好枚举后，直接使用枚举名称作为类型注解。</li></ol><hr><p>注意：形参 direction 的<strong>类型为枚举 Direction</strong>，那么，实参的<strong>值就应该是枚举 Direction 成员的任意一个</strong>。</p><p>访问枚举成员：</p><p><img src="'+P+'" alt=""></p><p>解释：类似于 JS 中的对象，直接通过<strong>点（.）语法访问</strong>枚举的成员。</p><hr><p>问题：我们把枚举成员作为了函数的实参，它的值是什么呢？</p><p><img src="'+L+'" alt=""></p><p>解释：通过将鼠标移入 <code>Direction.Up</code>，可以看到枚举成员 Up 的值为 0。</p><p>注意：<strong>枚举成员是有值的</strong>，默认为：<strong>从 0 开始自增的数值</strong>。</p><p>我们把，枚举成员的值为数字的枚举，称为：<strong>数字枚举</strong>。</p><p>当然，也可以给枚举中的成员初始化值。</p><p><img src="'+w+`" alt=""></p><hr><p><strong>字符串枚举</strong>：枚举成员的值是字符串。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token string">&#39;UP&#39;</span><span class="token punctuation">,</span>
    Down <span class="token operator">=</span> <span class="token string">&#39;DOWN&#39;</span><span class="token punctuation">,</span>
    Left <span class="token operator">=</span> <span class="token string">&#39;LEFT&#39;</span><span class="token punctuation">,</span>
    Right <span class="token operator">=</span> <span class="token string">&#39;RIGHT&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong>。</p><hr><p>枚举是 TS 为数不多的非 JavaScript 类型级扩展（不仅仅是类型）的特性之一。</p><p>因为：其他类型仅仅被当做类型，而<strong>枚举不仅用作类型，还提供值</strong>（枚举成员都是有值的）。</p><p>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<strong>枚举类型会被编译为 JS 代码</strong>！</p><p><img src="`+M+'" alt=""></p><p>说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表。</p><p>一般情况下，推荐使用<strong>字面量类型+联合类型组合</strong>的方式，因为相比枚举，这种方式更加直观、简洁、高效。</p><h2 id="_3-14-any-类型" tabindex="-1"><a class="header-anchor" href="#_3-14-any-类型" aria-hidden="true">#</a> 3.14 any 类型</h2><p>**原则：不推荐使用 any！**这会让 TypeScript 变为 “AnyScript”（失去 TS 类型保护的优势）。</p><p>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示。</p><p><img src="'+U+`" alt=""></p><p>解释：以上操作都不会有任何类型错误提示，即使可能存在错误！</p><p>尽可能的避免使用 any 类型，除非<strong>临时使用 any</strong> 来“避免”书写很长、很复杂的类型！</p><p>其他隐式具有 any 类型的情况：1 声明变量不提供类型也不提供默认值 2 函数参数不加类型。</p><p>注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型！</p><h2 id="_3-15-typeof" tabindex="-1"><a class="header-anchor" href="#_3-15-typeof" aria-hidden="true">#</a> 3.15 typeof</h2><p>众所周知，JS 中提供了 <code>typeof</code> 操作符，用来在 JS 中获取数据的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">&quot;HelloWorld&quot;</span><span class="token punctuation">)</span>    <span class="token comment">//打印string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际上，TS 也提供了 <code>typeof</code> 操作符：可以在<strong>类型上下文中</strong>引用变量或属性的类型（类型查询）。</p><p>使用场景：根据已有变量的值，获取该值的类型，来简化类型书写。</p><p><img src="`+A+'" alt=""></p><p>解释：</p><ol><li>使用 <code>typeof</code> 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同。</li><li><code>typeof</code> 出现在<strong>类型注解的位置</strong>（参数名称的冒号后面）所处的环境就在<strong>类型上下文</strong>（区别于 JS 代码）。</li><li>注意：<code>typeof</code> 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）。</li></ol>',175),j=[I];function q(C,G){return n(),p("div",null,j)}const O=s(B,[["render",q],["__file","03.html.vue"]]);export{O as default};
