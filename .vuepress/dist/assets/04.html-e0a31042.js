import{_ as s,o as t,c as o,a as l}from"./app-cb78d180.js";const r="/assets/20231221105433-d816aea2.png",n="/assets/20231221105534-ad0c5abf.png",i="/assets/20231221105629-e20f11ef.png",p="/assets/20231221110209-b87fb9e6.png",e="/assets/20231221110312-6c0190d8.png",a="/assets/20231221110424-33e90443.png",g="/assets/20231221111322-0286253d.png",c="/assets/20231221111421-865d5dbf.png",d="/assets/20231221111516-067dc196.png",_="/assets/20231221111641-7639ab6c.png",m={},h=l('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>TS 中的高级类型有很多，重点学习以下高级类型：</p><ol><li><p>class 类</p></li><li><p>类型兼容性</p></li><li><p>交叉类型</p></li><li><p>泛型 和 keyof</p></li><li><p>索引签名类型 和 索引查询类型</p></li><li><p>映射类型</p></li></ol><h2 id="_4-1-class-类" tabindex="-1"><a class="header-anchor" href="#_4-1-class-类" aria-hidden="true">#</a> 4.1 class 类</h2><p>TypeScript 全面支持 ES2015 中引入的 <strong>class</strong> 关键字，并为其添加了类型注解和其他语法（比如，可见性修饰符等）</p><p><img src="'+r+'" alt=""></p><p>解释：</p><ol><li>根据 TS 中的类型推论，可以知道 Person 类的实例对象 p 的类型是 Person。</li><li>TS 中的 class，不仅提供了 <strong>class 的语法功能，也作为一种类型存在</strong>。</li></ol><hr><p>实例属性初始化：</p><p><img src="'+n+'" alt=""></p><p>解释：</p><ol><li>声明成员 age，类型为 number（没有初始值）。</li><li>声明成员 gender，并设置初始值，此时，可省略类型注解（TS <strong>类型推论</strong> 为 string 类型）。</li></ol><hr><p>构造函数：</p><p><img src="'+i+'" alt=""></p><p>解释：</p><ol><li>成员初始化（比如，age: number）后，才可以通过 this.age 来访问实例成员。</li><li>需要为构造函数指定类型注解，否则会被隐式推断为 any；构造函数不需要返回值类型。</li></ol><hr><p>实例方法：</p><p><img src="'+p+'" alt=""></p><p>解释：方法的类型注解（参数和返回值）与函数用法相同。</p><hr><p>类继承的两种方式：1 <strong>extends</strong>（继承父类） 2 implements（实现接口）。</p><p>说明：JS 中只有 extends，而 implements 是 TS 提供的。</p><p><img src="'+e+'" alt=""></p><p>解释：</p><ol><li>通过 <strong>extends</strong> 关键字实现<strong>继承</strong>。</li><li>子类 Dog 继承父类 Animal，则 Dog 的实例对象 dog 就同时具有了父类 Animal 和 子类 Dog 的所有属性和方法。</li></ol><hr><p>类继承的两种方式：1 extends（继承父类） 2 <strong>implements</strong>（实现接口）。</p><p><img src="'+a+'" alt=""></p><p>解释：</p><ol><li>通过 <strong>implements</strong> 关键字让 class 实现接口。</li><li>Person 类实现接口 Singable 意味着，Person 类中必须提供 Singable 接口中指定的所有方法和属性。</li></ol><hr><p>类成员可见性：可以使用 TS 来<strong>控制 class 的方法或属性对于 class 外的代码是否可见</strong>。 可见性修饰符包括：1 <strong>public（公有的）</strong> 2 protected（受保护的） 3 private（私有的）。</p><ol><li>public：表示公有的、公开的，<strong>公有成员可以被任何地方访问</strong>，默认可见性。</li></ol><p><img src="'+g+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>public</strong> 关键字，来修饰该属性或方法是共有的。</li><li>因为 public 是默认可见性，所以，可以<strong>直接省略</strong>。</li></ol><hr><ol start="2"><li><strong>protected</strong>：表示<strong>受保护的</strong>，仅对其声明所在类和子类中（非实例对象）可见。</li></ol><p><img src="'+c+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>protected</strong> 关键字，来修饰该属性或方法是受保护的。</li><li>在子类的方法内部可以通过 this 来访问父类中受保护的成员，但是，<strong>对实例不可见</strong>！</li></ol><hr><ol start="3"><li><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的。</li></ol><p><img src="'+d+'" alt=""></p><p>解释：</p><ol><li>在类属性或方法前面添加 <strong>private</strong> 关键字，来修饰该属性或方法是私有的。</li><li>私有的属性或方法只在当前类中可见，对子类和实例对象也都是不可见的！</li></ol><hr><p>除了可见性修饰符之外，还有一个常见修饰符就是：<strong>readonly（只读修饰符）</strong>。</p><p><strong>readonly</strong>：表示<strong>只读，用来防止在构造函数之外对属性进行赋值</strong>。</p><p><img src="'+_+'" alt=""></p><p>解释：</p><ol><li>使用 <strong>readonly</strong> 关键字修饰该属性是只读的，注意<strong>只能修饰属性不能修饰方法</strong>。</li><li>注意：属性 age 后面的类型注解（比如，此处的 number）如果不加，则 age 的类型为 18 （<strong>字面量类型</strong>）。</li><li><strong>接口或者 {} 表示的对象类型，也可以使用 readonly</strong>。</li></ol><h2 id="_4-2-类型兼容性" tabindex="-1"><a class="header-anchor" href="#_4-2-类型兼容性" aria-hidden="true">#</a> 4.2 类型兼容性</h2>',56),b=[h];function f(u,S){return t(),o("div",null,b)}const y=s(m,[["render",f],["__file","04.html.vue"]]);export{y as default};
