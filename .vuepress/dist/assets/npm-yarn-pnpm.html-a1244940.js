import{_ as a,r,o as l,c as p,b as n,e,d as s,a as o}from"./app-c9e63f9e.js";const i="/assets/20231229143059-f8bb9d46.png",c={},d=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"前言"),n("p",null,"在前端工程化的背景下，依赖管理越来越得到重视，在开发的时候经常会接触到各种包管理工具，也会经常用到npm, yarn, pnpm等等指令，这篇文章主要是讲一讲这些概念之间的区别。")],-1),h=n("h2",{id:"npm",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#npm","aria-hidden":"true"},"#"),e(" npm")],-1),g={href:"https://link.juejin.cn/?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3DNode%26spm%3D1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},m=o('<h3 id="npm-v2" tabindex="-1"><a class="header-anchor" href="#npm-v2" aria-hidden="true">#</a> npm v2</h3><p>特性 ：采用简单的<strong>递归安装</strong>方法，将每个模块的依赖安装到自身的node_modules文件夹中，形成一个<strong>高度嵌套</strong>的依赖树。</p><p>可能存在的问题 ：</p><ol><li><p>项目规模比较大时，容易出现重复依赖，互相依赖，嵌套地狱等问题。</p></li><li><p>大量的重复依赖安装，造成空间资源的大量浪费，同时也会造成依赖安装时间过长（体积大，安装慢）。</p></li><li><p>由于嵌套层级过深会导致文件路径过长，在windows系统中可能会引发错误。 windows 文件系统中，文件路径不能超过 260 个字符长度。</p></li></ol><h3 id="npm-v3" tabindex="-1"><a class="header-anchor" href="#npm-v3" aria-hidden="true">#</a> npm v3</h3><p>特性 ：v3版本作了较大的更新，采取了<strong>扁平化</strong>的依赖结构。</p><p>可能存在的问题 ：</p>',7),k={href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm%2Fissues%2F8826",target:"_blank",rel:"noopener noreferrer"},u=o('<blockquote><p>npm@3 is sometimes slower than npm@2, though this is highly tree dependent. It is doing more, but all the same, folks&#39;d like it to be as fast as it can be. Profiling would be grand. 😉 This ticket exists as the tracker for npm@3 performance.</p></blockquote><h3 id="npm-v5" tabindex="-1"><a class="header-anchor" href="#npm-v5" aria-hidden="true">#</a> npm v5</h3><p>特性 ：引入了<strong>package-lock.json</strong>机制，保证了依赖安装的确定性。package-lock.json 的作用是锁定项目的依赖结构，理论上只要项目中存在 package-lock.json 文件，每次执行 npm install 后生成的node_modules 目录结构一定是完全相同的。</p><p>其实在package-lock.json机制出现之前，可以通过<strong>npm-shrinkwrap</strong>实现锁定依赖结构，但是npm-shrinkwrap的默认关闭的，需要主动执行。</p><h4 id="什么是语义版本控制-semver" tabindex="-1"><a class="header-anchor" href="#什么是语义版本控制-semver" aria-hidden="true">#</a> <strong>什么是语义版本控制（semver）？</strong></h4>',5),_={href:"https://link.juejin.cn/?target=http%3A%2F%2Fsemver.org%2F",target:"_blank",rel:"noopener noreferrer"},j=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;@types/react&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;^18.0.12&quot;</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的 <strong>^</strong> 表示指定的 MAJOR 版本号下, 所有更新的版本。这里会安装18.x.x的任意最新版本。</p>`,2),f=n("strong",null,"MAJOR",-1),v=n("strong",null,"MINOR",-1),b=n("strong",null,"PATCH",-1),x={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fabout-semantic-versioning",target:"_blank",rel:"noopener noreferrer"},F=n("p",null,[n("img",{src:i,alt:""})],-1),y=n("p",null,"从这里我们知道，即使是相同的package.json，每次安装的依赖并不都是完全一样的。这可能会导致一些问题。",-1),w=n("h4",{id:"为什么要引入-lockfiles-在npm中即为package-lock-json",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#为什么要引入-lockfiles-在npm中即为package-lock-json","aria-hidden":"true"},"#"),e(),n("strong",null,"为什么要引入 lockfiles？ 在npm中即为package-lock.json")],-1),N=n("p",null,[e("因为单一的 "),n("code",null,"package.json"),e(" 不能确定唯一的依赖树。 主要原因有两点：")],-1),M=n("li",null,[n("p",null,"不同版本的npm的安装依赖的策略和算法可能是不一样的。")],-1),A={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv6%2Fusing-npm%2Fsemver",target:"_blank",rel:"noopener noreferrer"},P=n("strong",null,"npm install",-1),q=n("code",null,"package.json",-1),B={href:"https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv6%2Fusing-npm%2Fsemver",target:"_blank",rel:"noopener noreferrer"},I=o('<p>因此, <strong>保证能够完整准确的还原项目依赖</strong> 就是<strong>lockfiles</strong>出现的原因。</p><h4 id="配置了package-lock-json-就一定会生效吗" tabindex="-1"><a class="header-anchor" href="#配置了package-lock-json-就一定会生效吗" aria-hidden="true">#</a> <strong>配置了package-lock.json，就一定会生效吗？</strong></h4><p><strong>不一定</strong>。</p><p>主要取决于npm版本以及 package-lock.json 和 package.json 之间的兼容关系。</p><table><thead><tr><th><strong>版本</strong></th><th style="text-align:left;"><strong>方案</strong></th></tr></thead><tbody><tr><td>NPM v5.0.x</td><td style="text-align:left;">依据 package-lock.json 安装依赖</td></tr><tr><td>NPM v5.1.0 - v5.4.2</td><td style="text-align:left;">如果package.json中声明的依赖版本规范有符合的更新的版本的时候，会忽略package-lock.json，按照package.json 安装依赖，并更新 package-lock.json</td></tr><tr><td>NPM &gt;v5.4.2</td><td style="text-align:left;">如果package.json中声明的依赖版本规范和package.lock.json中声明的依赖版本兼容，则依据package-lock.json 安装依赖；如果不兼容，按照package.json 安装依赖，并更新 package-lock.json</td></tr></tbody></table><h2 id="yarn" tabindex="-1"><a class="header-anchor" href="#yarn" aria-hidden="true">#</a> yarn</h2><p>yarn的出现解决了npm存在的一些比较严重的问题，主要是依赖的<strong>确定性</strong>，<strong>完整性</strong>，<strong>依赖安装速度</strong>等等。</p><p>这里要注意的是，yarn的出现是在2016年，此时 npm 处于 v3 时期，之后npm的更新也在不断实现yarn所拥有的一部分优点。这里所说的yarn的优点主要是针对早期的npm而言。</p><h4 id="yarn的优点" tabindex="-1"><a class="header-anchor" href="#yarn的优点" aria-hidden="true">#</a> yarn的优点</h4><ul><li><p><strong>速度快</strong> yarn的速度快是其特性共同表现出来的优点。</p></li><li><p><strong>依赖的确定性。</strong> 通过yarn.lock等机制，可以锁定依赖的版本，保证相同的依赖关系所安装的依赖是一致的。（npm v5中提出了package-lock.json实现相同的功能）</p></li><li><p><strong>扁平化依赖结构，减少依赖的冗余。</strong> yarn实现了扁平化依赖结构，避免了相同的依赖被重复安装，减小体积，加快安装速度。（npm v3中也做了相同的优化）</p></li><li><p><strong>网络性能更好</strong> 采用了请求排队的理念,类似于并发池连接,利用并行下载以最大化网络资源利用率;同时也引入了一种安装失败的重试机制。</p></li><li><p><strong>实现了离线模式</strong> 通过缓存机制，实现了离线模式。可以让 Yarn 在网络出现故障的情况下仍然能正常工作。（npm也具有缓存机制）</p></li></ul><h2 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> pnpm</h2><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2><p>https://juejin.cn/post/7107902138952450061</p>',13);function V(C,E){const t=r("ExternalLinkIcon");return l(),p("div",null,[d,h,n("p",null,[e("NPM（Node Package Managemnt）为Node创造了一个强大且丰富的生态，是"),n("a",g,[e("Node.js"),s(t)]),e("能够如此成功的主要原因之一。npm也是node.js内置的包管理器，和node一并安装。我们可以从npm的发展历程来看其的特性变化。")]),m,n("ol",null,[n("li",null,[e("采取扁平化的结构可以解决上述的问题。但是也会存在新的问题。为了生成扁平化的依赖树，npm需要遍历项目中的所有依赖关系，构建完整的依赖关系树，这是一个比较耗时的操作，所以也会造成依赖安装时间过长。这个是github上npm仓库中的一个"),n("a",k,[e("issue"),s(t)]),e("对此的描述")])]),u,n("p",null,[e("在了解为什么要引入锁定依赖结构的机制之前，我们需要了解npm的"),n("a",_,[e("语义版本控制（semver）"),s(t)]),e("。简单来说，npm包的版本描述并不是绝对精确的，而是包含一定语义（可变化）。我们可能会遇到形如这样的版本号。")]),j,n("p",null,[e("npm包的版本规范为"),f,e("."),v,e("."),b,e("。官网原文描述请"),n("a",x,[e("点击"),s(t)]),e("，不同的符号含义如下图所示。")]),F,y,w,N,n("ol",null,[M,n("li",null,[n("p",null,[e("就是上面提到的 "),n("a",A,[e("semver-range version"),s(t)]),e("。"),P,e(" 将根据 "),q,e(" 中的 "),n("a",B,[e("semver-range version"),s(t)]),e(" 更新依赖，如果某些依赖更新了，就可能会导致安装的依赖不同。")])])]),I])}const R=a(c,[["render",V],["__file","npm-yarn-pnpm.html.vue"]]);export{R as default};
